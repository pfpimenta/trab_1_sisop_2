
-> inicializar o backup

-> trocar de mensagens entre servidores

-> servidor primário avisar cada cliente que agora é o primário

-> cliente abrir porta para ouvir mensagens de vitória
-> cliente fechar conexão antiga e abrir conexão nova

-> colocar no RM primario a lista de todos RMs backups (ao iniciar e/ou na morte um RM backup)
	-> a cada modificação, essa lista é propagada pros backups

-> o primario envia um numero de ID unico para cada backup

-> parametros dos RMs backup:
	-> ip e porta do primario
	-> quando nao houver parametro, quer dizer que é o primario

-> replicação das atualizações do RM primario para os backups

-> sistema de timeout e retransmissao (dos dois lados)
	-> cliente: tenta mandar 3x, dai desliga
	-> servidor: tenta mandar 3x, dai mata a sessao mas deixa a notificacao na lista

-> nova porta listen do cliente:
	-> para receber aviso de troca de server primario
	-> cliente deve informar ao servidor o IP e porta desse socket ao conectar (CONNECT)

-> heartbeat
	-> cliente pro servidor primario
	-> servidor primario pros clientes
	-> servidor primario pros servidores backup
	-> servidores backup pro servidor primario

-> algoritmo de eleiçao (bully)

-> ao eleger um novo servidor primario
	-> checar se cada sessao continua viva

-> hook on exit, ctrl+c, ctrl+d (do servidor):
	-> mandar logout message do servidor pro cliente


// edge cases:
-> quando o numero de clientes for grande o suficiente para
   que as filas de mensagem de cada um demorem mais do que
   os segundo de sleep para serem lidas
	-> perda de mensagens




// bugfixes
-> client dá segfault quando tenta iniciar uma terceira sessão do mesmo username

-> server dá segfault quando recebe ctrl+c
	-> deveria também enviar um disconnect/shutdown pra avisar os usuários que está desligando?